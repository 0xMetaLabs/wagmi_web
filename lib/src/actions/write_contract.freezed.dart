// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'write_contract.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$WriteContractParameters {
  List<Map<dynamic, dynamic>> get abi => throw _privateConstructorUsedError;
  String get address => throw _privateConstructorUsedError;
  String get functionName => throw _privateConstructorUsedError;
  List<Map<String, dynamic>>? get accessList =>
      throw _privateConstructorUsedError;
  String? get account => throw _privateConstructorUsedError;
  List<dynamic>? get args => throw _privateConstructorUsedError;
  int? get chainId => throw _privateConstructorUsedError;
  String? get dataSuffix => throw _privateConstructorUsedError;
  BigInt? get gas => throw _privateConstructorUsedError;
  FeeValues? get feeValues => throw _privateConstructorUsedError;
  BigInt? get nonce => throw _privateConstructorUsedError;
  BigInt? get value => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        legacy,
    required TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip1559,
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip4844,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult? Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriteContractParametersLegacy value) legacy,
    required TResult Function(WriteContractParametersEIP1559 value) eip1559,
    required TResult Function(WriteContractParametersEIP4844 value) eip4844,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriteContractParametersLegacy value)? legacy,
    TResult? Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult? Function(WriteContractParametersEIP4844 value)? eip4844,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriteContractParametersLegacy value)? legacy,
    TResult Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult Function(WriteContractParametersEIP4844 value)? eip4844,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WriteContractParametersCopyWith<WriteContractParameters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WriteContractParametersCopyWith<$Res> {
  factory $WriteContractParametersCopyWith(WriteContractParameters value,
          $Res Function(WriteContractParameters) then) =
      _$WriteContractParametersCopyWithImpl<$Res, WriteContractParameters>;
  @useResult
  $Res call(
      {String address,
      String functionName,
      List<Map<String, dynamic>>? accessList,
      String? account,
      List<dynamic>? args,
      int? chainId,
      String? dataSuffix,
      BigInt? gas,
      BigInt? nonce,
      BigInt? value,
      String? type});
}

/// @nodoc
class _$WriteContractParametersCopyWithImpl<$Res,
        $Val extends WriteContractParameters>
    implements $WriteContractParametersCopyWith<$Res> {
  _$WriteContractParametersCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = null,
    Object? functionName = null,
    Object? accessList = freezed,
    Object? account = freezed,
    Object? args = freezed,
    Object? chainId = freezed,
    Object? dataSuffix = freezed,
    Object? gas = freezed,
    Object? nonce = freezed,
    Object? value = freezed,
    Object? type = freezed,
  }) {
    return _then(_value.copyWith(
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      functionName: null == functionName
          ? _value.functionName
          : functionName // ignore: cast_nullable_to_non_nullable
              as String,
      accessList: freezed == accessList
          ? _value.accessList
          : accessList // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>?,
      account: freezed == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as String?,
      args: freezed == args
          ? _value.args
          : args // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      chainId: freezed == chainId
          ? _value.chainId
          : chainId // ignore: cast_nullable_to_non_nullable
              as int?,
      dataSuffix: freezed == dataSuffix
          ? _value.dataSuffix
          : dataSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      gas: freezed == gas
          ? _value.gas
          : gas // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      nonce: freezed == nonce
          ? _value.nonce
          : nonce // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WriteContractParametersLegacyImplCopyWith<$Res>
    implements $WriteContractParametersCopyWith<$Res> {
  factory _$$WriteContractParametersLegacyImplCopyWith(
          _$WriteContractParametersLegacyImpl value,
          $Res Function(_$WriteContractParametersLegacyImpl) then) =
      __$$WriteContractParametersLegacyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Map> abi,
      String address,
      String functionName,
      List<Map<String, dynamic>>? accessList,
      String? account,
      List<dynamic>? args,
      int? chainId,
      String? dataSuffix,
      BigInt? gas,
      FeeValuesLegacy? feeValues,
      BigInt? nonce,
      BigInt? value,
      String? type});
}

/// @nodoc
class __$$WriteContractParametersLegacyImplCopyWithImpl<$Res>
    extends _$WriteContractParametersCopyWithImpl<$Res,
        _$WriteContractParametersLegacyImpl>
    implements _$$WriteContractParametersLegacyImplCopyWith<$Res> {
  __$$WriteContractParametersLegacyImplCopyWithImpl(
      _$WriteContractParametersLegacyImpl _value,
      $Res Function(_$WriteContractParametersLegacyImpl) _then)
      : super(_value, _then);

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? abi = null,
    Object? address = null,
    Object? functionName = null,
    Object? accessList = freezed,
    Object? account = freezed,
    Object? args = freezed,
    Object? chainId = freezed,
    Object? dataSuffix = freezed,
    Object? gas = freezed,
    Object? feeValues = freezed,
    Object? nonce = freezed,
    Object? value = freezed,
    Object? type = freezed,
  }) {
    return _then(_$WriteContractParametersLegacyImpl(
      abi: null == abi
          ? _value._abi
          : abi // ignore: cast_nullable_to_non_nullable
              as List<Map>,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      functionName: null == functionName
          ? _value.functionName
          : functionName // ignore: cast_nullable_to_non_nullable
              as String,
      accessList: freezed == accessList
          ? _value._accessList
          : accessList // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>?,
      account: freezed == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as String?,
      args: freezed == args
          ? _value._args
          : args // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      chainId: freezed == chainId
          ? _value.chainId
          : chainId // ignore: cast_nullable_to_non_nullable
              as int?,
      dataSuffix: freezed == dataSuffix
          ? _value.dataSuffix
          : dataSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      gas: freezed == gas
          ? _value.gas
          : gas // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      feeValues: freezed == feeValues
          ? _value.feeValues
          : feeValues // ignore: cast_nullable_to_non_nullable
              as FeeValuesLegacy?,
      nonce: freezed == nonce
          ? _value.nonce
          : nonce // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$WriteContractParametersLegacyImpl
    extends WriteContractParametersLegacy {
  const _$WriteContractParametersLegacyImpl(
      {required final List<Map> abi,
      required this.address,
      required this.functionName,
      final List<Map<String, dynamic>>? accessList,
      this.account,
      final List<dynamic>? args,
      this.chainId,
      this.dataSuffix,
      this.gas,
      this.feeValues,
      this.nonce,
      this.value,
      this.type})
      : _abi = abi,
        _accessList = accessList,
        _args = args,
        super._();

  final List<Map> _abi;
  @override
  List<Map> get abi {
    if (_abi is EqualUnmodifiableListView) return _abi;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_abi);
  }

  @override
  final String address;
  @override
  final String functionName;
  final List<Map<String, dynamic>>? _accessList;
  @override
  List<Map<String, dynamic>>? get accessList {
    final value = _accessList;
    if (value == null) return null;
    if (_accessList is EqualUnmodifiableListView) return _accessList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? account;
  final List<dynamic>? _args;
  @override
  List<dynamic>? get args {
    final value = _args;
    if (value == null) return null;
    if (_args is EqualUnmodifiableListView) return _args;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? chainId;
  @override
  final String? dataSuffix;
  @override
  final BigInt? gas;
  @override
  final FeeValuesLegacy? feeValues;
  @override
  final BigInt? nonce;
  @override
  final BigInt? value;
  @override
  final String? type;

  @override
  String toString() {
    return 'WriteContractParameters.legacy(abi: $abi, address: $address, functionName: $functionName, accessList: $accessList, account: $account, args: $args, chainId: $chainId, dataSuffix: $dataSuffix, gas: $gas, feeValues: $feeValues, nonce: $nonce, value: $value, type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriteContractParametersLegacyImpl &&
            const DeepCollectionEquality().equals(other._abi, _abi) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.functionName, functionName) ||
                other.functionName == functionName) &&
            const DeepCollectionEquality()
                .equals(other._accessList, _accessList) &&
            (identical(other.account, account) || other.account == account) &&
            const DeepCollectionEquality().equals(other._args, _args) &&
            (identical(other.chainId, chainId) || other.chainId == chainId) &&
            (identical(other.dataSuffix, dataSuffix) ||
                other.dataSuffix == dataSuffix) &&
            (identical(other.gas, gas) || other.gas == gas) &&
            (identical(other.feeValues, feeValues) ||
                other.feeValues == feeValues) &&
            (identical(other.nonce, nonce) || other.nonce == nonce) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_abi),
      address,
      functionName,
      const DeepCollectionEquality().hash(_accessList),
      account,
      const DeepCollectionEquality().hash(_args),
      chainId,
      dataSuffix,
      gas,
      feeValues,
      nonce,
      value,
      type);

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriteContractParametersLegacyImplCopyWith<
          _$WriteContractParametersLegacyImpl>
      get copyWith => __$$WriteContractParametersLegacyImplCopyWithImpl<
          _$WriteContractParametersLegacyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        legacy,
    required TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip1559,
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip4844,
  }) {
    return legacy(abi, address, functionName, accessList, account, args,
        chainId, dataSuffix, gas, feeValues, nonce, value, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult? Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
  }) {
    return legacy?.call(abi, address, functionName, accessList, account, args,
        chainId, dataSuffix, gas, feeValues, nonce, value, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
    required TResult orElse(),
  }) {
    if (legacy != null) {
      return legacy(abi, address, functionName, accessList, account, args,
          chainId, dataSuffix, gas, feeValues, nonce, value, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriteContractParametersLegacy value) legacy,
    required TResult Function(WriteContractParametersEIP1559 value) eip1559,
    required TResult Function(WriteContractParametersEIP4844 value) eip4844,
  }) {
    return legacy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriteContractParametersLegacy value)? legacy,
    TResult? Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult? Function(WriteContractParametersEIP4844 value)? eip4844,
  }) {
    return legacy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriteContractParametersLegacy value)? legacy,
    TResult Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult Function(WriteContractParametersEIP4844 value)? eip4844,
    required TResult orElse(),
  }) {
    if (legacy != null) {
      return legacy(this);
    }
    return orElse();
  }
}

abstract class WriteContractParametersLegacy extends WriteContractParameters {
  const factory WriteContractParametersLegacy(
      {required final List<Map> abi,
      required final String address,
      required final String functionName,
      final List<Map<String, dynamic>>? accessList,
      final String? account,
      final List<dynamic>? args,
      final int? chainId,
      final String? dataSuffix,
      final BigInt? gas,
      final FeeValuesLegacy? feeValues,
      final BigInt? nonce,
      final BigInt? value,
      final String? type}) = _$WriteContractParametersLegacyImpl;
  const WriteContractParametersLegacy._() : super._();

  @override
  List<Map> get abi;
  @override
  String get address;
  @override
  String get functionName;
  @override
  List<Map<String, dynamic>>? get accessList;
  @override
  String? get account;
  @override
  List<dynamic>? get args;
  @override
  int? get chainId;
  @override
  String? get dataSuffix;
  @override
  BigInt? get gas;
  @override
  FeeValuesLegacy? get feeValues;
  @override
  BigInt? get nonce;
  @override
  BigInt? get value;
  @override
  String? get type;

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriteContractParametersLegacyImplCopyWith<
          _$WriteContractParametersLegacyImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WriteContractParametersEIP1559ImplCopyWith<$Res>
    implements $WriteContractParametersCopyWith<$Res> {
  factory _$$WriteContractParametersEIP1559ImplCopyWith(
          _$WriteContractParametersEIP1559Impl value,
          $Res Function(_$WriteContractParametersEIP1559Impl) then) =
      __$$WriteContractParametersEIP1559ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Map<String, dynamic>> abi,
      String address,
      String functionName,
      List<Map<String, dynamic>>? accessList,
      String? account,
      List<dynamic>? args,
      int? chainId,
      String? dataSuffix,
      BigInt? gas,
      FeeValuesEIP1559? feeValues,
      BigInt? nonce,
      BigInt? value,
      String? type});
}

/// @nodoc
class __$$WriteContractParametersEIP1559ImplCopyWithImpl<$Res>
    extends _$WriteContractParametersCopyWithImpl<$Res,
        _$WriteContractParametersEIP1559Impl>
    implements _$$WriteContractParametersEIP1559ImplCopyWith<$Res> {
  __$$WriteContractParametersEIP1559ImplCopyWithImpl(
      _$WriteContractParametersEIP1559Impl _value,
      $Res Function(_$WriteContractParametersEIP1559Impl) _then)
      : super(_value, _then);

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? abi = null,
    Object? address = null,
    Object? functionName = null,
    Object? accessList = freezed,
    Object? account = freezed,
    Object? args = freezed,
    Object? chainId = freezed,
    Object? dataSuffix = freezed,
    Object? gas = freezed,
    Object? feeValues = freezed,
    Object? nonce = freezed,
    Object? value = freezed,
    Object? type = freezed,
  }) {
    return _then(_$WriteContractParametersEIP1559Impl(
      abi: null == abi
          ? _value._abi
          : abi // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      functionName: null == functionName
          ? _value.functionName
          : functionName // ignore: cast_nullable_to_non_nullable
              as String,
      accessList: freezed == accessList
          ? _value._accessList
          : accessList // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>?,
      account: freezed == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as String?,
      args: freezed == args
          ? _value._args
          : args // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      chainId: freezed == chainId
          ? _value.chainId
          : chainId // ignore: cast_nullable_to_non_nullable
              as int?,
      dataSuffix: freezed == dataSuffix
          ? _value.dataSuffix
          : dataSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      gas: freezed == gas
          ? _value.gas
          : gas // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      feeValues: freezed == feeValues
          ? _value.feeValues
          : feeValues // ignore: cast_nullable_to_non_nullable
              as FeeValuesEIP1559?,
      nonce: freezed == nonce
          ? _value.nonce
          : nonce // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$WriteContractParametersEIP1559Impl
    extends WriteContractParametersEIP1559 {
  const _$WriteContractParametersEIP1559Impl(
      {required final List<Map<String, dynamic>> abi,
      required this.address,
      required this.functionName,
      final List<Map<String, dynamic>>? accessList,
      this.account,
      final List<dynamic>? args,
      this.chainId,
      this.dataSuffix,
      this.gas,
      this.feeValues,
      this.nonce,
      this.value,
      this.type})
      : _abi = abi,
        _accessList = accessList,
        _args = args,
        super._();

  final List<Map<String, dynamic>> _abi;
  @override
  List<Map<String, dynamic>> get abi {
    if (_abi is EqualUnmodifiableListView) return _abi;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_abi);
  }

  @override
  final String address;
  @override
  final String functionName;
  final List<Map<String, dynamic>>? _accessList;
  @override
  List<Map<String, dynamic>>? get accessList {
    final value = _accessList;
    if (value == null) return null;
    if (_accessList is EqualUnmodifiableListView) return _accessList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? account;
  final List<dynamic>? _args;
  @override
  List<dynamic>? get args {
    final value = _args;
    if (value == null) return null;
    if (_args is EqualUnmodifiableListView) return _args;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? chainId;
  @override
  final String? dataSuffix;
  @override
  final BigInt? gas;
  @override
  final FeeValuesEIP1559? feeValues;
  @override
  final BigInt? nonce;
  @override
  final BigInt? value;
  @override
  final String? type;

  @override
  String toString() {
    return 'WriteContractParameters.eip1559(abi: $abi, address: $address, functionName: $functionName, accessList: $accessList, account: $account, args: $args, chainId: $chainId, dataSuffix: $dataSuffix, gas: $gas, feeValues: $feeValues, nonce: $nonce, value: $value, type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriteContractParametersEIP1559Impl &&
            const DeepCollectionEquality().equals(other._abi, _abi) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.functionName, functionName) ||
                other.functionName == functionName) &&
            const DeepCollectionEquality()
                .equals(other._accessList, _accessList) &&
            (identical(other.account, account) || other.account == account) &&
            const DeepCollectionEquality().equals(other._args, _args) &&
            (identical(other.chainId, chainId) || other.chainId == chainId) &&
            (identical(other.dataSuffix, dataSuffix) ||
                other.dataSuffix == dataSuffix) &&
            (identical(other.gas, gas) || other.gas == gas) &&
            (identical(other.feeValues, feeValues) ||
                other.feeValues == feeValues) &&
            (identical(other.nonce, nonce) || other.nonce == nonce) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_abi),
      address,
      functionName,
      const DeepCollectionEquality().hash(_accessList),
      account,
      const DeepCollectionEquality().hash(_args),
      chainId,
      dataSuffix,
      gas,
      feeValues,
      nonce,
      value,
      type);

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriteContractParametersEIP1559ImplCopyWith<
          _$WriteContractParametersEIP1559Impl>
      get copyWith => __$$WriteContractParametersEIP1559ImplCopyWithImpl<
          _$WriteContractParametersEIP1559Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        legacy,
    required TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip1559,
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip4844,
  }) {
    return eip1559(abi, address, functionName, accessList, account, args,
        chainId, dataSuffix, gas, feeValues, nonce, value, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult? Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
  }) {
    return eip1559?.call(abi, address, functionName, accessList, account, args,
        chainId, dataSuffix, gas, feeValues, nonce, value, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
    required TResult orElse(),
  }) {
    if (eip1559 != null) {
      return eip1559(abi, address, functionName, accessList, account, args,
          chainId, dataSuffix, gas, feeValues, nonce, value, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriteContractParametersLegacy value) legacy,
    required TResult Function(WriteContractParametersEIP1559 value) eip1559,
    required TResult Function(WriteContractParametersEIP4844 value) eip4844,
  }) {
    return eip1559(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriteContractParametersLegacy value)? legacy,
    TResult? Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult? Function(WriteContractParametersEIP4844 value)? eip4844,
  }) {
    return eip1559?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriteContractParametersLegacy value)? legacy,
    TResult Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult Function(WriteContractParametersEIP4844 value)? eip4844,
    required TResult orElse(),
  }) {
    if (eip1559 != null) {
      return eip1559(this);
    }
    return orElse();
  }
}

abstract class WriteContractParametersEIP1559 extends WriteContractParameters {
  const factory WriteContractParametersEIP1559(
      {required final List<Map<String, dynamic>> abi,
      required final String address,
      required final String functionName,
      final List<Map<String, dynamic>>? accessList,
      final String? account,
      final List<dynamic>? args,
      final int? chainId,
      final String? dataSuffix,
      final BigInt? gas,
      final FeeValuesEIP1559? feeValues,
      final BigInt? nonce,
      final BigInt? value,
      final String? type}) = _$WriteContractParametersEIP1559Impl;
  const WriteContractParametersEIP1559._() : super._();

  @override
  List<Map<String, dynamic>> get abi;
  @override
  String get address;
  @override
  String get functionName;
  @override
  List<Map<String, dynamic>>? get accessList;
  @override
  String? get account;
  @override
  List<dynamic>? get args;
  @override
  int? get chainId;
  @override
  String? get dataSuffix;
  @override
  BigInt? get gas;
  @override
  FeeValuesEIP1559? get feeValues;
  @override
  BigInt? get nonce;
  @override
  BigInt? get value;
  @override
  String? get type;

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriteContractParametersEIP1559ImplCopyWith<
          _$WriteContractParametersEIP1559Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WriteContractParametersEIP4844ImplCopyWith<$Res>
    implements $WriteContractParametersCopyWith<$Res> {
  factory _$$WriteContractParametersEIP4844ImplCopyWith(
          _$WriteContractParametersEIP4844Impl value,
          $Res Function(_$WriteContractParametersEIP4844Impl) then) =
      __$$WriteContractParametersEIP4844ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Map> abi,
      String address,
      String functionName,
      List<Map<String, dynamic>>? accessList,
      String? account,
      List<dynamic>? args,
      int? chainId,
      String? dataSuffix,
      BigInt? gas,
      FeeValuesEIP4844? feeValues,
      BigInt? nonce,
      BigInt? value,
      String? type});
}

/// @nodoc
class __$$WriteContractParametersEIP4844ImplCopyWithImpl<$Res>
    extends _$WriteContractParametersCopyWithImpl<$Res,
        _$WriteContractParametersEIP4844Impl>
    implements _$$WriteContractParametersEIP4844ImplCopyWith<$Res> {
  __$$WriteContractParametersEIP4844ImplCopyWithImpl(
      _$WriteContractParametersEIP4844Impl _value,
      $Res Function(_$WriteContractParametersEIP4844Impl) _then)
      : super(_value, _then);

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? abi = null,
    Object? address = null,
    Object? functionName = null,
    Object? accessList = freezed,
    Object? account = freezed,
    Object? args = freezed,
    Object? chainId = freezed,
    Object? dataSuffix = freezed,
    Object? gas = freezed,
    Object? feeValues = freezed,
    Object? nonce = freezed,
    Object? value = freezed,
    Object? type = freezed,
  }) {
    return _then(_$WriteContractParametersEIP4844Impl(
      abi: null == abi
          ? _value._abi
          : abi // ignore: cast_nullable_to_non_nullable
              as List<Map>,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      functionName: null == functionName
          ? _value.functionName
          : functionName // ignore: cast_nullable_to_non_nullable
              as String,
      accessList: freezed == accessList
          ? _value._accessList
          : accessList // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>?,
      account: freezed == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as String?,
      args: freezed == args
          ? _value._args
          : args // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      chainId: freezed == chainId
          ? _value.chainId
          : chainId // ignore: cast_nullable_to_non_nullable
              as int?,
      dataSuffix: freezed == dataSuffix
          ? _value.dataSuffix
          : dataSuffix // ignore: cast_nullable_to_non_nullable
              as String?,
      gas: freezed == gas
          ? _value.gas
          : gas // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      feeValues: freezed == feeValues
          ? _value.feeValues
          : feeValues // ignore: cast_nullable_to_non_nullable
              as FeeValuesEIP4844?,
      nonce: freezed == nonce
          ? _value.nonce
          : nonce // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as BigInt?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$WriteContractParametersEIP4844Impl
    extends WriteContractParametersEIP4844 {
  const _$WriteContractParametersEIP4844Impl(
      {required final List<Map> abi,
      required this.address,
      required this.functionName,
      final List<Map<String, dynamic>>? accessList,
      this.account,
      final List<dynamic>? args,
      this.chainId,
      this.dataSuffix,
      this.gas,
      this.feeValues,
      this.nonce,
      this.value,
      this.type})
      : _abi = abi,
        _accessList = accessList,
        _args = args,
        super._();

  final List<Map> _abi;
  @override
  List<Map> get abi {
    if (_abi is EqualUnmodifiableListView) return _abi;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_abi);
  }

  @override
  final String address;
  @override
  final String functionName;
  final List<Map<String, dynamic>>? _accessList;
  @override
  List<Map<String, dynamic>>? get accessList {
    final value = _accessList;
    if (value == null) return null;
    if (_accessList is EqualUnmodifiableListView) return _accessList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? account;
  final List<dynamic>? _args;
  @override
  List<dynamic>? get args {
    final value = _args;
    if (value == null) return null;
    if (_args is EqualUnmodifiableListView) return _args;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? chainId;
  @override
  final String? dataSuffix;
  @override
  final BigInt? gas;
  @override
  final FeeValuesEIP4844? feeValues;
  @override
  final BigInt? nonce;
  @override
  final BigInt? value;
  @override
  final String? type;

  @override
  String toString() {
    return 'WriteContractParameters.eip4844(abi: $abi, address: $address, functionName: $functionName, accessList: $accessList, account: $account, args: $args, chainId: $chainId, dataSuffix: $dataSuffix, gas: $gas, feeValues: $feeValues, nonce: $nonce, value: $value, type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WriteContractParametersEIP4844Impl &&
            const DeepCollectionEquality().equals(other._abi, _abi) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.functionName, functionName) ||
                other.functionName == functionName) &&
            const DeepCollectionEquality()
                .equals(other._accessList, _accessList) &&
            (identical(other.account, account) || other.account == account) &&
            const DeepCollectionEquality().equals(other._args, _args) &&
            (identical(other.chainId, chainId) || other.chainId == chainId) &&
            (identical(other.dataSuffix, dataSuffix) ||
                other.dataSuffix == dataSuffix) &&
            (identical(other.gas, gas) || other.gas == gas) &&
            (identical(other.feeValues, feeValues) ||
                other.feeValues == feeValues) &&
            (identical(other.nonce, nonce) || other.nonce == nonce) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_abi),
      address,
      functionName,
      const DeepCollectionEquality().hash(_accessList),
      account,
      const DeepCollectionEquality().hash(_args),
      chainId,
      dataSuffix,
      gas,
      feeValues,
      nonce,
      value,
      type);

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WriteContractParametersEIP4844ImplCopyWith<
          _$WriteContractParametersEIP4844Impl>
      get copyWith => __$$WriteContractParametersEIP4844ImplCopyWithImpl<
          _$WriteContractParametersEIP4844Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        legacy,
    required TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip1559,
    required TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)
        eip4844,
  }) {
    return eip4844(abi, address, functionName, accessList, account, args,
        chainId, dataSuffix, gas, feeValues, nonce, value, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult? Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult? Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
  }) {
    return eip4844?.call(abi, address, functionName, accessList, account, args,
        chainId, dataSuffix, gas, feeValues, nonce, value, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesLegacy? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        legacy,
    TResult Function(
            List<Map<String, dynamic>> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP1559? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip1559,
    TResult Function(
            List<Map> abi,
            String address,
            String functionName,
            List<Map<String, dynamic>>? accessList,
            String? account,
            List<dynamic>? args,
            int? chainId,
            String? dataSuffix,
            BigInt? gas,
            FeeValuesEIP4844? feeValues,
            BigInt? nonce,
            BigInt? value,
            String? type)?
        eip4844,
    required TResult orElse(),
  }) {
    if (eip4844 != null) {
      return eip4844(abi, address, functionName, accessList, account, args,
          chainId, dataSuffix, gas, feeValues, nonce, value, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WriteContractParametersLegacy value) legacy,
    required TResult Function(WriteContractParametersEIP1559 value) eip1559,
    required TResult Function(WriteContractParametersEIP4844 value) eip4844,
  }) {
    return eip4844(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WriteContractParametersLegacy value)? legacy,
    TResult? Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult? Function(WriteContractParametersEIP4844 value)? eip4844,
  }) {
    return eip4844?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WriteContractParametersLegacy value)? legacy,
    TResult Function(WriteContractParametersEIP1559 value)? eip1559,
    TResult Function(WriteContractParametersEIP4844 value)? eip4844,
    required TResult orElse(),
  }) {
    if (eip4844 != null) {
      return eip4844(this);
    }
    return orElse();
  }
}

abstract class WriteContractParametersEIP4844 extends WriteContractParameters {
  const factory WriteContractParametersEIP4844(
      {required final List<Map> abi,
      required final String address,
      required final String functionName,
      final List<Map<String, dynamic>>? accessList,
      final String? account,
      final List<dynamic>? args,
      final int? chainId,
      final String? dataSuffix,
      final BigInt? gas,
      final FeeValuesEIP4844? feeValues,
      final BigInt? nonce,
      final BigInt? value,
      final String? type}) = _$WriteContractParametersEIP4844Impl;
  const WriteContractParametersEIP4844._() : super._();

  @override
  List<Map> get abi;
  @override
  String get address;
  @override
  String get functionName;
  @override
  List<Map<String, dynamic>>? get accessList;
  @override
  String? get account;
  @override
  List<dynamic>? get args;
  @override
  int? get chainId;
  @override
  String? get dataSuffix;
  @override
  BigInt? get gas;
  @override
  FeeValuesEIP4844? get feeValues;
  @override
  BigInt? get nonce;
  @override
  BigInt? get value;
  @override
  String? get type;

  /// Create a copy of WriteContractParameters
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WriteContractParametersEIP4844ImplCopyWith<
          _$WriteContractParametersEIP4844Impl>
      get copyWith => throw _privateConstructorUsedError;
}
